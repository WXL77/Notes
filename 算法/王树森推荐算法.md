## 目录
1. [推荐算法基础知识](#推荐算法基础知识)
2. [召回](#召回)

##
## 推荐算法基础知识
1. 常见指标
   - 短期消费指标  
     - 点击率 = 点击次数 / 曝光次数  
     - 点赞率 = 点赞次数 / 点击次数  
     - 阅读完成率 = 滑动到底次数 / 点击次数 * 归一化函数（跟笔记长度有关）<br/><br/>
      ```
      一味追求短期消费指标会导致用户很快失去兴趣，不再活跃，所以还需要兼顾多样性，有助于提高用户黏性，提高用户留存。
      ```
   - 北极星指标（衡量推荐系统好坏最重要的指标）
     - 用户规模：日活（DAU）、月活（MAU）
     - 消费：
     - 发布：

## 召回
协同过滤召回
### 基于物品的协同过滤（itemCF）
<mark> ItemCF的问题：两篇笔记受众不同，但由于被分享到一个小圈子，导致很多用户同时交互过这两篇笔记，ItemCF会误判两篇笔记的相似度
1. 原理：用户喜欢物品 $i_1$，那么用户可能喜欢与物品 $i_1$ 相似的物品 $i_2$
2. 物品相似度（根据用户的行为）：若喜欢 $i_1$与 $i_2$ 的用户有很大的重叠，则 $i_1$ 与 $i_2$ 相似  
     **公式：**
     - 不考虑喜欢的程度： $$sim(i_1,i_2)=\frac{|\omega_1 \cap \omega_2|}{\sqrt{|\omega_1| \cdotp |\omega_2|}}$$
     - 考虑喜欢的程度： $$sim(i_1,i_2)=\frac{\sum_{v \in V} like(v,i_1) \cdotp like(v,i_2)}{\sqrt{\sum_{u_1 \in \omega_1 like^2(u_1,i_1)}} \cdotp \sqrt{\sum_{u_2 \in \omega_2 like^2(u_2,i_2)}}}$$
3. ItemCF召回的完整流程
   - 事先做离线计算  
       - 建立 “用户 → 物品” 的索引  
         `实现：`给定任意用户ID，可以找到他近期感兴趣的物品列表，以及其对物品的兴趣分数    
         `步骤：`记录每个用户最近点击、交互过的物品ID，以及对每个物品的兴趣分数
       - 建立 “物品 → 物品” 的索引  
         `实现：`给定任意物品ID，可以快速找到它最相似的 K 个物品    
         `步骤：`计算物品之间的相似度  
         &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;对于每个物品，索引它最相似的 K 个物品
   - 线上做召回  
     - 给定用户ID，通过 “用户 → 物品” 的索引，找到用户近期感兴趣的物品列表 $（last-n）$  
     - 对于 $last-n$ 列表中的每个物品，通过 “物品 → 物品” 的索引，找到 $top-k$ 相似物品
     - 对于取回的相似物品（最多有 $nk$ 个），用公式预估用户对物品的兴趣分数： $$\sum_{j} like(user,item_j) \times sim(item_j,item)$$
     - 返回分数最高的100个物品，最为推荐结果<br/><br/> 
    ````
    索引的意义在于避免枚举所有的物品，使得离线计算量大，线上计算量小
    ````

### SWing召回通道
1. 原理：为解决ItemCF的问题，给用户设置权重，解决小圈子问题
2. 用户重合度：
   - 用户 $u_1$ 喜欢的物品记作集合 $J_1$
   - 用户 $u_2$ 喜欢的物品记作集合 $J_2$
   - 定义两个用户的重合度： $$overlap(u_1,u_2) = |J_1 \cap J_2|$$
   - 用户 $u_1$ 和 $u_2$ 的重合度高，则他们可能来自于一个小圈子，要降低他们的权重
3. 物品相似度：  
   - 喜欢物品 $i_1$ 的用户记作集合 $\omega_1$
   - 喜欢物品 $i_2$ 的用户记作集合 $\omega_2$
   - 定义交集 $$V = \omega_1 \cap \omega_2$$
   - 两个物品的相似度： $$sim(i_1,i_2) = \sum_{u_1 \in V} \sum_{u_2 \in V} \frac{1}{\alpha + overlap(u_1,u_2)}$$（ $\alpha$ 是个人工设置的参数）

### 基于用户的协同过滤（UserCF）
1. 原理：用户 $user_1$ 和 $user_2$ 相似，则用户 $user_1$ 可能会喜欢 $user_2$ 喜欢的物品 
2. 用户相似度：
   - 不区分热门冷门物品：
      - 用户 $u_1$ 喜欢的物品记作集合 $J_1$
      - 用户 $u_2$ 喜欢的物品记作集合 $J_2$
      - 定义交集 $$I=J_1 \cap J_2$$
      - 两个用户的相似度： $$sim(u_1,u_2) = \frac{|I|}{\sqrt{|J_1| \cdotp |J_2|}}$$
   - 降低热门物品的权重：（越热门的物品越无法反映出用户独特的兴趣，大家都喜欢，对计算相似度是没有帮助的，反过来，越冷门的物品，越能反映出相似度）
      - 用户 $u_1$ 喜欢的物品记作集合 $J_1$
      - 用户 $u_2$ 喜欢的物品记作集合 $J_2$
      - 定义交集 $$I=J_1 \cap J_2$$
      - 两个用户的相似度： $$sim(u_1,u_2) = \frac{\sum_{l \in I}\frac{1}{log(1+n_l)}}{\sqrt{|J_1| \cdotp |J_2|}}$$ （$n_l$代表喜欢物品l的用户数量，反映物品的热门程度）
3. UserCF召回的完整流程
   - 事先做离线计算  
     - 建立 “用户 → 物品” 的索引  
       `实现：`给定任意用户ID，可以找到他近期感兴趣的物品列表，以及其对物品的兴趣分数  
       `步骤：`记录每个用户最近点击、交互过的物品ID，以及对每个物品的兴趣分数   
     - 建立 “用户 → 用户” 的索引  
       `实现：`给定任意用户ID，可以快速找到他最相似的 K 个用户，以及用户相似度的分数  
       `步骤：`对于每个用户，索引他最相似的 K 个用户，以及用户相似度的分数
   - 线上做召回
     - 给定用户ID，通过 “用户 → 用户” 索引，找到 $top-K$ 相似的用户
     - 对于每个 $top-K$ 相似用户，通过 “用户 → 物品” 索引，找到用户近期感兴趣的物品列表 $last-n$
     - 对于召回的 $nk$ 个相似物品，用公式预估用户对每个物品的兴趣分数
     - 返回分数最高的100个物品，作为召回结果
       
       
   







